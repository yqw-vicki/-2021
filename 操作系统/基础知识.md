# CPU的两种状态  
**用户态和核心态**  
用户态只能执行非特权指令  
核心态既可以执行特权指令又可以执行非特权指令  
用程序状态字寄存器(PSW)来保存状态
用户态->核心态的转换是通过中断来实现的  
核心态->用户态的转换只需要设置PSW为“用户态”就可以了  

# 中断
中断分为内中断和外中断。 内中断来自于CPU内部信号，与当前执行的指令有关，外中断来自CPU外部，与当前执行的指令无关  
外中断的处理：
step1: 执行完每个指令后，cpu都会检查是否有中断信号产生  
step2: 如果有中断信号产生，就需要保护被中断进程的cpu环境
step3: 根据中断的类型，转入相应的中断处理程序(核心态)  
step4: 恢复原来的cpu运行环境，返回原进程继续往下执行

# 进程
进程的组成：PCB, 程序段，数据段， PCB是进程存在的唯一标识  
PCB是操作系统对进程管理存放的地方  
进程是资源分配，接受调度的基本单位  

进程的三个状态：运行态，就绪态，阻塞态
就绪态：进程具备了除CPU以外的所有资源  
阻塞态： 等待某个事件的发生，而暂时不能运行。等待结束后进入就绪态，等待cpu的服务
运行态转换为就绪态：时间片到，或者cpu被抢占（被动行为）  
运行态转换为阻塞态：进程用系统调用的方式申请某个系统资源，或者请求等待某个事情的发生(主动行为)  
还有另外两种状态：创建态和终止态  
运行态转换为终止态：正常结束，异常结束，外界干预  
## 原语  
计算机**进程的控制**通常由原语完成。 所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，**在执行过程中不可被中断**。  
进程控制就是实现进程状态间的转换  

## 进程通信  
* 共享存储，进程之间的访问是互斥的  
* 管道通信：管道是指连接读写进程的一个特殊的共享文件。其实就是在内存中开辟了一个大小固定的缓冲区。  管道只能实现半双工通信，即一个时刻只能有一个方向的通信。各进程要互斥的访问管道。  
数据以字符流的形式写入管道，当管道写满时，写进程就会被阻塞，等待进程将数据取走。读进程将管道中的数据全部取走后，管道变空，读进程将会被阻塞。如果没有写满就不允许读，如果管道不为空，
就不允许写。数据一旦被读出以后，就会被管道抛弃，因此只能有一个读进程  
* 消息传递  
进程之间通过操作系统提供的“接收/发送信息”原语进行数据交换  

# 线程  
线程是基本的cpu执行单元，也是程序执行流的最小单位  
用户级线程：线程控制不需要操作系统的切换，对操作系统透明  
内核级线程：内核级线程是处理机分配的单位  
## 多线程模型  
几个用户级线程映射到几个内核级线程的模型  
多对一：多个用户级线程对应到一个内核级线程上。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。缺点：一旦一个用户级线程被阻塞后，
整个进程都会被阻塞，并发性不高，特别是没法在多核运行  
一对一：  
多对多模型： 

# 进程的调度  
调度就是确定某种规则来确定处理任务的顺序  
* 高级调度(作业调度) 
按照某种规则，从**外存**的后备队列中选择一个作业，给它分配内存资源等必要的资源，并建立相应的进程，使得它获得竞争处理机的权力  
外存与内存间的调度，每个作业只能调入一次，调出一次，作业调入时会建立相应的PCB,作业调出的时候会撤销相应的PCB  
无-创建态-就绪态  
* 中级调度
将暂时不能运行的进程调出外存进行等待。等它具备了运行条件且内存也有些空间时，才从外存调入内存。注意在调出时，进程的PCB依然保留在内存中，此时进程的状态为**挂起**状态， 
被挂起的PCB会被放到挂起队列中  
中级调度就是决定那个处于挂起状态的进程被重新调入内存， 可能会发生多次。  
挂起态-就绪态  
* 低级调度（进程调度）  
就绪态-运行态  

## 七状态模型  
原本只有五种状态：创建态，就绪态，运行态，阻塞态，终止态。  
七状态模型引入了就绪挂起和阻塞挂起两种状态  
如果内存空间不够，将就绪状态变成就绪挂起状态。同理，阻塞挂起状态也是由阻塞状态转变来的  

## 临界资源  
一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。  

## 调度方式  
* 非剥夺调度方式：只允许进程自动放弃cpu  
* 剥夺调度方式  

# 进程同步/进程异步  
所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。  
当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。  
同步/异步是**消息通知的机制**  

# 阻塞与非阻塞  
阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。  
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.  
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。  
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
阻塞与非阻塞是**等待消息通知时的状态**  

## 同步/异步和阻塞/非阻塞的理解以及组合  
同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。  
同步体现在：等待下载完成通知；  
阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；  

同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。  
同步体现在：等待下载完成通知，但是要在；  
非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】  

异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。  
异步体现在：下载完成“叮”一声通知；  
阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；  

异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。  
异步体现在：下载完成“叮”一声通知；  
非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】  

同步的情况下，是由处理消息者自己去**等待消息是否被触发**，而异步的情况下是由**触发机制**来通知处理消息者，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁：
