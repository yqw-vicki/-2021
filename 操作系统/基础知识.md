# CPU的两种状态  
**用户态和核心态**  
用户态只能执行非特权指令  
核心态既可以执行特权指令又可以执行非特权指令  
用程序状态字寄存器(PSW)来保存状态
用户态->核心态的转换是通过中断来实现的  
核心态->用户态的转换只需要设置PSW为“用户态”就可以了  

# 中断
中断分为内中断和外中断。 内中断来自于CPU内部信号，与当前执行的指令有关，外中断来自CPU外部，与当前执行的指令无关  
外中断的处理：
step1: 执行完每个指令后，cpu都会检查是否有中断信号产生  
step2: 如果有中断信号产生，就需要保护被中断进程的cpu环境
step3: 根据中断的类型，转入相应的中断处理程序(核心态)  
step4: 恢复原来的cpu运行环境，返回原进程继续往下执行

# 进程
进程的组成：PCB, 程序段，数据段， PCB是进程存在的唯一标识  
PCB是操作系统对进程管理存放的地方  
进程是资源分配，接受调度的基本单位  

进程的三个状态：运行态，就绪态，阻塞态
就绪态：进程具备了除CPU以外的所有资源  
阻塞态： 等待某个事件的发生，而暂时不能运行。等待结束后进入就绪态，等待cpu的服务
运行态转换为就绪态：时间片到，或者cpu被抢占（被动行为）  
运行态转换为阻塞态：进程用系统调用的方式申请某个系统资源，或者请求等待某个事情的发生(主动行为)  
还有另外两种状态：创建态和终止态  
运行态转换为终止态：正常结束，异常结束，外界干预  
## 原语  
计算机**进程的控制**通常由原语完成。 所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，**在执行过程中不可被中断**。  
进程控制就是实现进程状态间的转换  

## 进程通信  
* 共享存储，进程之间的访问是互斥的  
* 管道通信：管道是指连接读写进程的一个特殊的共享文件。其实就是在内存中开辟了一个大小固定的缓冲区。  管道只能实现半双工通信，即一个时刻只能有一个方向的通信。各进程要互斥的访问管道。  
数据以字符流的形式写入管道，当管道写满时，写进程就会被阻塞，等待进程将数据取走。读进程将管道中的数据全部取走后，管道变空，读进程将会被阻塞。如果没有写满就不允许读，如果管道不为空，
就不允许写。数据一旦被读出以后，就会被管道抛弃，因此只能有一个读进程  
* 消息传递  
进程之间通过操作系统提供的“接收/发送信息”原语进行数据交换  

# 线程  
线程是基本的cpu执行单元，也是程序执行流的最小单位  
用户级线程：线程控制不需要操作系统的切换，对操作系统透明  
内核级线程：内核级线程是处理机分配的单位  
## 多线程模型  
几个用户级线程映射到几个内核级线程的模型  
多对一：多个用户级线程对应到一个内核级线程上。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。缺点：一旦一个用户级线程被阻塞后，
整个进程都会被阻塞，并发性不高，特别是没法在多核运行  
一对一：  
多对多模型： 

# 进程的调度  
调度就是确定某种规则来确定处理任务的顺序  
* 高级调度(作业调度) 
按照某种规则，从**外存**的后备队列中选择一个作业，给它分配内存资源等必要的资源，并建立相应的进程，使得它获得竞争处理机的权力  
外存与内存间的调度，每个作业只能调入一次，调出一次，作业调入时会建立相应的PCB,作业调出的时候会撤销相应的PCB  
无-创建态-就绪态  
* 中级调度
将暂时不能运行的进程调出外存进行等待。等它具备了运行条件且内存也有些空间时，才从外存调入内存。注意在调出时，进程的PCB依然保留在内存中，此时进程的状态为**挂起**状态， 
被挂起的PCB会被放到挂起队列中  
中级调度就是决定那个处于挂起状态的进程被重新调入内存， 可能会发生多次。  
挂起态-就绪态  
* 低级调度（进程调度）  
就绪态-运行态  

## 七状态模型  
原本只有五种状态：创建态，就绪态，运行态，阻塞态，终止态。  
七状态模型引入了就绪挂起和阻塞挂起两种状态  
如果内存空间不够，将就绪状态变成就绪挂起状态。同理，阻塞挂起状态也是由阻塞状态转变来的  




