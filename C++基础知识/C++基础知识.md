## 编译-连接的过程
**编译的过程**
* 预处理--.cpp->.i预处理，主要处理以下指令：宏定义指令，条件编译指令，头文件包含指令。 预处理所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令，头文件都被展开（递归展开）的文件。
* 编译 -- .i->.s 生成符号，将源代码指令转化为汇编指令 
所有的全局变量静态变量都是数据，其他的都是指令
所有的数据都会生成符号，而指令只有函数名会生成符号
生成的符号会保存在段中，方便后面查询使用。内联函数就是在这步
* 汇编-- .s->.o 将生成的汇编代码翻译成机器码  

**链接的过程**  
将生成的目标文件和系统库文件进行链接，最终生成了可以在特定平台运行的可执行文件。具体来说包括以下几个步骤：
* 合并段--合并段，调整段偏移，将各个文件不同的段合并起来，每个.o文件的.text段合并在一起.data段合并在一起，这样，在生成的可执行 文件中，各个段都只有一个
* 调整段偏移--合并段之后，必须进行的一个操作就是调整段偏移和段长度。每个进程都有自己的虚拟地址空间，都是从0地址开始的，将各个文件的各个段加载进来之后，段的大小会有所变化，
* 汇总所有符号--每个obj文件在编译时都会生成自己的符号表，所以我们要把这些符号都合并起来进行符号解析
* 完成符号的重定位--在进行合并段，调整段偏移时，输入文件的各个段在连接后的虚拟地址就已经确定了，这一步完成后，连接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所以段内各个符号的地址也已经是确定的了，只不过连接器需要给每个符号加上一个偏移量，使他们能够调整到正确的虚拟地址，这就是符号的重定位过程  

## C++和C的区别
C++和C最大的区别是用于解决问题的思想方法不同。C是结构化语言， C程序设计考虑的是如何通过一个过程将输入转化成输出，C++程序设计考虑的是如何构造一个对象模型，让这个模型能配合对应的问题。  
C实现了C++的过程化，C++又在C的基础上有所加强，引入了函数重载，内联函数，异常处理等，同时C++又拓展了面向对象设计的内容，如类，继承，虚继承，模板包括容器等

## 引用头文件时<>和“”的区别
<>表示这个文件是一个工程或者标准头文件，编译是会先查找预定义的目录，如果是“ ”表示这个文件是用户提供的头文件，查找的时候先从当前目录开始。  
 
## C++预处理器  
预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 
所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。  
#define 预处理
#define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：#define macro-name replacement-text  
#define 来定义一个带有参数的宏，#define MIN(a,b) ((a)<(b) ? (a) : (b)) 注意这里的要把参数用括号()括起来， 如果不加(),a参数可能会被拆开，因为宏替换只是单纯的替换，比如#define MUL(a, b) (a\*b)，这里没有加括号，那么现在MUL(1+2,3+2)经过宏替换就会变成(1+2\*3+2)
宏替换是在预编译阶段完成，MIN(2,3)先被替换成((a)<(b)?(a):(b))再被替换成2<3?2:3,之后进行函数调用计算，函数调用在运行阶段进行。   
**宏替换的特点**
* 宏替换只作替换，不做计算，不做表达式求解
* 函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存
* 宏的哑实结合不存在类型，也没有类型转换。
* 函数只有一个返回值，利用宏则可以设法得到多个值
* 宏展开使源程序变长，函数调用不会
* 宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）

**条件编译**  
有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。
只在调试时进行编译，调试开关可以使用一个宏来实现  
#ifdef DEBUG
   cerr <<"Variable x = " << x << endl;
#endif
用#if 0 语句注释掉程序的一部分  
#if 0
   不进行编译的代码
#endif  

可以将#用在replacement_text中， 将replacement_text转换为用引号引起来的字符串 #define MKSTR( x ) #x cout<<MKSTR(hello)的输出就是"hello"
可以用##在replacement_text中，用来连接replacement_text中两个参数 #define CONCAT( x, y )  x ## y   输出CONCAT(x,y)的结果就是xy,如果之前定义了int xy=10,那么CONCAT(x,y)的输出结果就是10.  

**C++中预定义的宏**  
\__LINE\__	这会在程序编译时包含当前行号。  
\__FILE__	这会在程序编译时包含当前文件名。  
\__DATE__	这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。  
\__TIME__	这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。

## C++中sort函数的比较器  
三种写法：
1. 在类中重载成员函数 bool operator<(const 类名& a)--希望a排在this对象的后面
2. 在类中定义静态成员函数或者定义全局函数 static bool comparator(const 类名& a, const 类名& b)--希望a排在b的  
原因： 非静态成员函数是依赖于具体对象的，而std::sort这类函数是全局的，因此无法再sort中调用非静态成员函数。静态成员函数或者全局函数是不依赖于具体对象的, 可以独立访问，无须创建任何对象实例就可以访问。同时静态成员函数不可以调用类的非静态成员。  
3. 定义函数对象   
struct comp{  
    bool operator(const 类名& a, const 类名& b){  
    }  
};  
