## 编译-连接的过程
**编译的过程**
* 预处理--.cpp->.i预处理，主要处理以下指令：宏定义指令，条件编译指令，头文件包含指令。 预处理所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令，头文件都被展开（递归展开）的文件。
* 编译 -- .i->.s 生成符号，将源代码指令转化为汇编指令 
所有的全局变量静态变量都是数据，其他的都是指令
所有的数据都会生成符号，而指令只有函数名会生成符号
生成的符号会保存在段中，方便后面查询使用。内联函数就是在这步
* 汇编-- .s->.o 将生成的汇编代码翻译成机器码  

**链接的过程**  
将生成的目标文件和系统库文件进行链接，最终生成了可以在特定平台运行的可执行文件。具体来说包括以下几个步骤：
* 合并段--合并段，调整段偏移，将各个文件不同的段合并起来，每个.o文件的.text段合并在一起.data段合并在一起，这样，在生成的可执行 文件中，各个段都只有一个
* 调整段偏移--合并段之后，必须进行的一个操作就是调整段偏移和段长度。每个进程都有自己的虚拟地址空间，都是从0地址开始的，将各个文件的各个段加载进来之后，段的大小会有所变化，
* 汇总所有符号--每个obj文件在编译时都会生成自己的符号表，所以我们要把这些符号都合并起来进行符号解析
* 完成符号的重定位--在进行合并段，调整段偏移时，输入文件的各个段在连接后的虚拟地址就已经确定了，这一步完成后，连接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所以段内各个符号的地址也已经是确定的了，只不过连接器需要给每个符号加上一个偏移量，使他们能够调整到正确的虚拟地址，这就是符号的重定位过程  

## C++和C的区别
C++和C最大的区别是用于解决问题的思想方法不同。C是结构化语言， C程序设计考虑的是如何通过一个过程将输入转化成输出，C++程序设计考虑的是如何构造一个对象模型，让这个模型能配合对应的问题。  
C实现了C++的过程化，C++又在C的基础上有所加强，引入了函数重载，内联函数，异常处理等，同时C++又拓展了面向对象设计的内容，如类，继承，虚继承，模板包括容器等

## 引用头文件时<>和“”的区别
<>表示这个文件是一个工程或者标准头文件，编译是会先查找预定义的目录，如果是“ ”表示这个文件是用户提供的头文件，查找的时候先从当前目录开始。  
 
## C++预处理器  
预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 
所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。  
#define 预处理
#define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：#define macro-name replacement-text  
#define 来定义一个带有参数的宏，#define MIN(a,b) ((a)<(b) ? (a) : (b)) 注意这里的要把参数用括号()括起来， 如果不加(),a参数可能会被拆开，因为宏替换只是单纯的替换，比如#define MUL(a, b) (a\*b)，这里没有加括号，那么现在MUL(1+2,3+2)经过宏替换就会变成(1+2\*3+2)
宏替换是在预编译阶段完成，MIN(2,3)先被替换成((a)<(b)?(a):(b))再被替换成2<3?2:3,之后进行函数调用计算，函数调用在运行阶段进行。   
**宏替换的特点**
* 宏替换只作替换，不做计算，不做表达式求解
* 函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存
* 宏的哑实结合不存在类型，也没有类型转换。
* 函数只有一个返回值，利用宏则可以设法得到多个值
* 宏展开使源程序变长，函数调用不会
* 宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）

**条件编译**  
有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。
只在调试时进行编译，调试开关可以使用一个宏来实现  
#ifdef DEBUG
   cerr <<"Variable x = " << x << endl;
#endif
用#if 0 语句注释掉程序的一部分  
#if 0
   不进行编译的代码
#endif  

可以将#用在replacement_text中， 将replacement_text转换为用引号引起来的字符串 #define MKSTR( x ) #x cout<<MKSTR(hello)的输出就是"hello"
可以用##在replacement_text中，用来连接replacement_text中两个参数 #define CONCAT( x, y )  x ## y   输出CONCAT(x,y)的结果就是xy,如果之前定义了int xy=10,那么CONCAT(x,y)的输出结果就是10.  

**C++中预定义的宏**  
\__LINE\__	这会在程序编译时包含当前行号。  
\__FILE__	这会在程序编译时包含当前文件名。  
\__DATE__	这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。  
\__TIME__	这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。

## C++中sort函数的比较器  
三种写法：
1. 在类中重载成员函数 bool operator<(const 类名& a)--希望a排在this对象的后面
2. 在类中定义静态成员函数或者定义全局函数 static bool comparator(const 类名& a, const 类名& b)--希望a排在b的  
原因： 非静态成员函数是依赖于具体对象的，而std::sort这类函数是全局的，因此无法再sort中调用非静态成员函数。静态成员函数或者全局函数是不依赖于具体对象的, 可以独立访问，无须创建任何对象实例就可以访问。同时静态成员函数不可以调用类的非静态成员。  
3. 定义函数对象   
struct comp{  
    bool operator(const 类名& a, const 类名& b){  
    }  
};  

## C++中五大内存分区  
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
5、程序代码区—存放函数体的二进制代码。#define常量只会存在于代码区  

## static关键字的作用  
* static用于全局变量前，会改变全局变量的作用域。非静态全局变量的作用域是整个源程序，在所有源文件中都有效；静态全局变量的作用域只在定义该变量的源文件中有效。如果在头文件中定义了非静态的全局变量，那么当头文件被多次调用时就会出现重复定义的问题。因为每个引用该头文件的源文件都会重新对该变量进行创建。但是如果是静态全局变量，那么不会报错，但是在不同源文件中变量的地址不同，相当于在不同文件中重新创建了该变量  
* static用于局部变量，改变了局部变量的存储方式。静态局部变量存储在静态区，当局部静态变量离开作用域时不会被销毁，直到再次被使用时值不会改变  
* static用于函数，static函数的作用域仅在当前源文件中，非静态函数的作用域是整个源程序，对于这些可以在源文件之外使用的函数应该在头文件中声明，要使用这些函数时就包含这个头文件。  
* static用在类中，修饰类的成员变量，该变量属于类，不属于任何对象，可以实现对象间的数据共享。在类中声明，在类外定义。  
  修饰类的成员函数，类中的静态函数必须调用静态变量，不能调用非静态成员或函数，也不能使用this指针。  
  
## extern 关键字
extern两种用法  
* 当extern用在变量或者函数前，表示声明当前变量或者函数的定义在别的文件中，因为只是声明，所以不会分配内存空间。extern变量可以声明多次，但只能定义一次，而且必须在函数外定义为全局变量。如果在头文件中声明了extern变量，那么在包含该头文件的源文件中都可以使用该变量。  
* extern"C": 让编译器以 C 语言的命名规则来查找函数. extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。  
**extern和static**  
 (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.  
 (2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.  
    static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它.
    
## map与unordered_map
* map： #include < map >
map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，O(log n)时间内完成查找，插入和删除，使用中序遍历可将键值按照从小到大遍历出来。

* unordered_map: #include < unordered_map >
unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。unordered_map 一般是由一个大vector，vector元素节点可挂接链表来解决冲突来实现。hash_table最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。

* 优缺点以及适用处
* map：
优点：
1.有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
2.红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用处：对于那些有顺序要求的问题，用map会更高效一些

* unordered_map：
优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

* 我爱王永青
    
